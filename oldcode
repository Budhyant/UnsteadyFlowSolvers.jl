
function add_tev!(tev_x, tev_z, bnd_x, bnd_z, ndiv, u, dt, c)
    ntev = length(tev_x)
    if (ntev == 0)
        push!(tev_x, bnd_x[ndiv] + 0.5*u*dt)
        push!(tev_z, bnd_z[ndiv])
    else
        push!(tev_x, bnd_x[ndiv]+(1./3.)*(tev_x[ntev]-bnd_x[ndiv]))
        push!(tev_z, bnd_z[ndiv]+(1./3.)*(tev_z[ntev]-bnd_z[ndiv]))
    end
    return tev_x, tev_z
end




# function add_lev()
#     if (levflag == 0)
#         push!(lev_x, bnd_x[1] + 0.5*le_vel_x*dt)
#         push!(lev_z, bnd_z[1] + 0.5*le_vel_z*dt)
#     else
#         push!(lev_x, bnd_x[1]+(1./3.)*(lev_x[nlev-1]-bnd_x[1]))
#         push!(lev_x, bnd_z[1]+(1./3.)*(lev_z[nlev-1]-bnd_z[1]))
#     end
# end

function calc_kelv(tev_iter,kelv_enf,theta,dtheta,ndiv,u_ref,c,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u,alpha,alphadot,hdot,pvt,cam_slope,x)
    kelv = kelv_enf
    tev_s[length(tev_s)] = tev_iter
    for i = 1:length(lev_s)
        kelv = kelv + lev_s[i]
    end

    for i = 1:length(tev_s)
        kelv = kelv + tev_s[i]
    end

    _, _, dwash = downwash(lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u,alpha,alphadot,hdot,pvt,c,cam_slope,ndiv,x)

    _, _, gam = bcirc(theta,ndiv,dtheta,u_ref,c,dwash)

    kelv = kelv + gam
    return kelv
end



function lautat(;c=1, u_ref=1, foil_name = "flat_plate", pvt = 0.0, cm_pvt = 0.0)

    #Program variables
    vcore = 0.02
    tol = 10e-10     #Tolerance or iteration #Not used
    iter_max = 100  #Max. iterations #Not used

    ndiv = 70       #No. of divisions along chord on airfoil
    naterm = 45     #Number of fourier terms used to compute vorticity at a location on chord
    deldist = 10   #Nondimensional deletion distance for vortices

    #Decide time range and step
    t = [0:0.015:10;];
    nstep = length(t);

    alpha = Array(Float64,nstep)
    h = Array(Float64,nstep)
    alphadot = Array(Float64,nstep)
    hdot = Array(Float64,nstep)
    u = Array(Float64,nstep)

    x = Array(Float64,ndiv)
    theta = Array(Float64,ndiv)
    cam = Array(Float64,ndiv)
    cam_slope = Array(Float64,ndiv)
    bnd_x = Array(Float64,ndiv)
    bnd_z = Array(Float64,ndiv)
    bv_s = Array(Float64,ndiv)
    bv_x = Array(Float64,ndiv)
    bv_z = Array(Float64,ndiv)

    cl = Array(Float64,nstep)
    cd = Array(Float64,nstep)
    cm = Array(Float64,nstep)

    aterm = Array(Float64,naterm)
    aterm_prev = Array(Float64,naterm)

    tev_x = Float64[];
    tev_z = Float64[];
    lev_x = Float64[];
    lev_z = Float64[];
    tev_s = Float64[];
    lev_s = Float64[];
    lev_vc = Float64[];
    tev_vc = Float64[];
    bv_vc = Float64[];
    uind_tev = Float64[];
    wind_tev = Float64[];
    uind_lev = Float64[];
    wind_lev = Float64[];

    uind = Array(Float64,ndiv)
    wind = Array(Float64,ndiv)
    dwash = Array(Float64,ndiv)

    adot = Array(Float64,3)

    #Generate kinematics
    alpha = eld_fn(t);
    [h[i] = 0. for i = 1:nstep]
    [u[i] = 1. for i = 1:nstep]

    #Dimensionalise quantities

    for i = 1:nstep
        t[i] = t[i]*c/u_ref;
        h[i] = h[i]*c;
        u[i] = u[i]*u_ref;
        alpha[i] = alpha[i]*pi/180
    end
    deldist = deldist*c
    vcore = vcore*c

    #Generate derivatives (backward difference)
    alphadot[2:nstep] = diff(alpha)./diff(t)
    hdot[2:nstep] = diff(h)./diff(t)
    alphadot[1] = 2*alphadot[2] - alphadot[3]
    hdot[1] = 2*hdot[2] - hdot[3]


    #Defining chordwise divisions
    dtheta = pi/(ndiv - 1);
    for i = 1:ndiv
        theta[i] = (real(i) - 1)*dtheta;
        x[i] = 0.5c*(1 - cos(theta[i]));
    end

    #Determine camberslope on airfoil from airfoil input file
    if (foil_name == "flat_plate")
        cam[1:ndiv] = 0
        cam_slope[1:ndiv] = 0
    else
        cam,cam_slope = camber_calc(x,foil_name);
    end

    #Initial conditions
    cl[1] = 0
    cd[1] = 0
    cm[1] = 0
    kelv_enf = 0
    a0 = 0
    a0_prev = 0
    aterm_prev[1:3] = 0
    gam = 0
    kelv_enf = 0
    tev_iter = 0

    #Iterate over time steps
    for ist = 2:nstep

        #Update bound vortex positions
        bnd_x, bnd_z = update_bound(bnd_x,bnd_z,alphadot[ist],alpha[ist],h[ist],hdot[ist],pvt,ndiv,c,x,cam,u[ist],t[ist]-t[ist-1])
        #Shed a TEV at every time step
        tev_x, tev_z = add_tev!(tev_x, tev_z, bnd_x, bnd_z, ndiv, u[ist], t[ist]-t[ist-1], c)
        push!(tev_vc, vcore)
        push!(tev_s,0.01) #Initial value for iteration

        #Iteration to solve for tev strength
        #tev_s[length(tev_s)] = tev_solve(kelv_enf,theta,dtheta,ndiv,u_ref,c,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u[ist],alpha[ist],alphadot[ist],hdot[ist],pvt,cam_slope,x)

        tev_s[length(tev_s)] = fzero(tev_iter -> calc_kelv(tev_iter,kelv_enf,theta,dtheta,ndiv,u_ref,c,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u[ist],alpha[ist],alphadot[ist],hdot[ist],pvt,cam_slope,x),-0.01,[-1, 1])


        #Quantities to be used in force calculation
        uind, wind, dwash = downwash(lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u[ist],alpha[ist],alphadot[ist],hdot[ist],pvt,c,cam_slope,ndiv,x)
        a0, aterm[1], gam = bcirc(theta,ndiv,dtheta,u_ref,c,dwash)

        a0dot, adot = calc_adot(a0,a0_prev,aterm,aterm_prev,dwash,theta,dtheta,t[ist]-t[ist-1],u_ref,ndiv)

        aterm = calc_aterm(aterm,naterm,theta,dtheta,ndiv,u_ref,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u[ist],alpha[ist],alphadot[ist],hdot[ist],pvt,c,cam_slope,x,dwash)

        #Set previous values of aterm to be used for derivatives in next time step
        a0_prev = a0
        aterm_prev[1:3]=aterm[1:3]

        #Calculate bound vortex strengths
        bv_s, bv_x, bv_z, bv_vc = calc_bndvorts(a0,aterm,naterm,theta,dtheta,ndiv,bnd_x,bnd_z,u_ref,c)

        # !Wake rollup
        uind_tev = Array(Float64,length(tev_s))
        uind_lev = Array(Float64,length(lev_s))
        wind_tev = Array(Float64,length(tev_s))
        wind_lev = Array(Float64,length(lev_s))

        uind_tev[1:length(tev_s)] = 0
        wind_tev[1:length(tev_s)] = 0
        uind_lev[1:length(lev_s)] = 0
        wind_lev[1:length(lev_s)] = 0

        uind_tev, wind_tev = ind_vel(uind_tev,wind_tev,[lev_s; tev_s; bv_s[2:ndiv]],[lev_x; tev_x; bv_x[2:ndiv]],[lev_z; tev_z; bv_z[2:ndiv]],[lev_vc; tev_vc; bv_vc[2:ndiv]],tev_x,tev_z)

        uind_lev, wind_lev = ind_vel(uind_lev,wind_lev,[lev_s; tev_s; bv_s[2:ndiv]],[lev_x; tev_x; bv_x[2:ndiv]],[lev_z; tev_z; bv_z[2:ndiv]],[lev_vc; tev_vc; bv_vc[2:ndiv]],lev_x,lev_z)

        tev_x, tev_z = convect_vort(tev_x,tev_z,uind_tev,wind_tev,t[ist]-t[ist-1])
        lev_x, lev_z = convect_vort(lev_x,lev_z,uind_lev,wind_lev,t[ist]-t[ist-1])

        cl[ist], cd[ist], cm[ist] = force_calc(u[ist],alpha[ist],hdot[ist],u_ref,c,a0,aterm,a0dot, adot,uind,wind,ndiv,bv_s,x,cm_pvt)
    end

return t, alpha, cl, cd, cm
end

function tev_solve(kelv_enf,theta,dtheta,ndiv,u_ref,c,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u,alpha,alphadot,hdot,pvt,cam_slope,x)

    kelv = Array(Float64,iter_max)
    tev_iter = Array(Float64,iter_max)

    iter = 1
    tev_iter[iter] = 0.
    kelv[iter] = calc_kelv(tev_iter[iter],kelv_enf,theta,dtheta,ndiv,u_ref,c,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u,alpha,alphadot,hdot,pvt,cam_slope,x)
    tev_iter[iter+1] = -0.01

    for iter = 2:iter_max+1
        if (iter > iter_max)
            println("1D iteration failed")
            break
        end
        kelv[iter] = calc_kelv(tev_iter[iter],kelv_enf,theta,dtheta,ndiv,u_ref,c,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u,alpha,alphadot,hdot,pvt,cam_slope,x)
        if (abs(kelv[iter])<tol)
            break
        end
        dkelv = (kelv[iter] - kelv[iter-1])/(tev_iter[iter] - tev_iter[iter-1])
        tev_iter[iter+1] = tev_iter[iter]-(kelv[iter]/dkelv)
    end
    return tev_iter[iter]
end


function downwash(lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u,alpha,alphadot,hdot,pvt,c,cam_slope,ndiv,x)
    uind = Array(Float64,ndiv)
    wind = Array(Float64,ndiv)
    uind[:] = 0
    wind[:] = 0
    dwash = Array(Float64,ndiv)

    uind, wind = ind_vel(uind,wind,[lev_s; tev_s],[lev_x; tev_x],[lev_z; tev_z],[lev_vc; tev_vc],bnd_x,bnd_z)

    for ib = 1:ndiv
        dwash[ib] = -u*sin(alpha) - uind[ib]*sin(alpha) + hdot*cos(alpha) - wind[ib]*cos(alpha) - alphadot*(x[ib] - pvt*c) + cam_slope[ib]*(uind[ib]*cos(alpha) + u*cos(alpha) + hdot*sin(alpha) - wind[ib]*sin(alpha))
    end
    return uind, wind, dwash
end

function bcirc(theta,ndiv,dtheta,u_ref,c,dwash)

    a0 = 0
    a1 = 0
    for id = 2:ndiv
        a0 = a0 + ((dwash[id] + dwash[id-1])/2)*dtheta
        a1 = a1 + ((dwash[id]*cos(theta[id])+dwash[id-1]*cos(theta[id-1]))/2)*dtheta
    end
    a0 = -a0/(u_ref*pi)
    a1 = 2.*a1/(u_ref*pi)
    gam = u_ref*c*pi*(a0 + a1)/2.
    #println(gam,a0,a1)
    return a0, a1, gam
end


function calc_adot(a0,a0_prev,aterm,aterm_prev,dwash,theta,dtheta,dt,u_ref,ndiv)
    adot = Array(Float64,3)
    aterm[2:3] = 0

    for ia=2:3
        for ib = 2:ndiv
            aterm[ia] = aterm[ia] + (dwash[ib]*cos(ia*theta[ib])+dwash[ib-1]*cos(ia*theta[ib-1]))*dtheta/2.
        end
        aterm[ia] = (2./(u_ref*pi))*aterm[ia]
    end

    a0dot = (a0 - a0_prev)/dt
    adot[1]=(aterm[1]-aterm_prev[1])/dt
    adot[2]=(aterm[2]-aterm_prev[2])/dt
    adot[3]=(aterm[3]-aterm_prev[3])/dt
    return a0dot, adot
end




function calc_aterm(aterm, naterm,theta,dtheta,ndiv,u_ref,lev_s,lev_x,lev_z,lev_vc,tev_s,tev_x,tev_z,tev_vc,bnd_x,bnd_z,u,alpha,alphadot,hdot,pvt,c,cam_slope,x,dwash)

    for ia = 2:naterm
        for ib = 2:ndiv
            aterm[ia] = aterm[ia] + (dwash[ib]*cos(ia*theta[ib]) + dwash[ib-1]*cos(ia*theta[ib-1]))*dtheta/2.
        end
        aterm[ia] = (2./(u_ref*pi))*aterm[ia]
    end
    return aterm
end
